# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FGGMLImporterDialog
                                 A QGIS plugin
 国土地理院の標高数値モデルのzipファイルをインポートします。
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-09-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by chiakikun
        email                : chiakikungm@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from PyQt5.QtWidgets import QFileDialog, QMessageBox
import gdal
import zipfile
import glob
import time
import numpy as np 
import xml.etree.ElementTree as et
from PyQt5.QtCore import QThread, QFileInfo
from PyQt5.Qt import pyqtSignal
import qgis.core
import qgis.utils

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'fg_gml_importer_dialog_base.ui'))


class FGGMLImporterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(FGGMLImporterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.__running__ = False

    def clickclose(self):
        if self.__running__:    # キャンセル
            self.calc.stopped = True
            self.__running__ = False
            self.controlenable(True)
        else:                   # 閉じる
            self.close()

    def clickfolderselect(self):
        path = QFileDialog.getExistingDirectory(None, "", "")
        self.folderPathEdit.setText(path)

    def onMemoAdd(self, value):        
        self.memoViewr.append(value)

    def onQuit(self):
        for d in self.__decompfiles:
            fileInfo = QFileInfo(d)
            baseName = fileInfo.baseName()
            layer = qgis.utils.iface.addRasterLayer(d, baseName)
        self.controlenable(True)
        QtWidgets.QMessageBox.about(self, "FG GML Importer", "終了しました")
        self.__running__ = False

    def onDecompFileAdd(self, file):
        self.__decompfiles.append(file)

    def controlenable(self, flg):
        self.folderPathEdit.setEnabled(flg)
        self.folderselectButton.setEnabled(flg)
        self.execButton.setEnabled(flg)
        if flg:
                self.closeButton.setText('閉じる')
        else:
                self.closeButton.setText('キャンセル')

    def clickexec(self):
        self.__decompfiles = []
        folder = self.folderPathEdit.text()
        self.memoViewr.clear()

        if not (os.path.exists(folder) and (os.path.isdir(folder))):
            QtWidgets.QMessageBox.information(None, "エラー", "指定したフォルダが見つかりませんでした。;"+ folder , QMessageBox.Ok)
            self.done(-1)
            return

        filelist = glob.glob(folder + "\FG-GML-*-DEM*.zip")
        if len(filelist) == 0:
            QtWidgets.QMessageBox.information(None, "エラー", "zipファイルは見つかりませんでした。;"+ folder , QMessageBox.Ok)
            return

        self.controlenable(False)
        self.__running__ = True
        self.calc = ZipToTiff(filelist)
        self.calc.memoAdd.connect(self.onMemoAdd)
        self.calc.finish.connect(self.onQuit)
        self.calc.decompfileAdd.connect(self.onDecompFileAdd)
        self.calc.start()    

class ZipToTiff(QThread):
    memoAdd = pyqtSignal(str)
    finish = pyqtSignal()
    decompfileAdd = pyqtSignal(str)

    def __init__(self, arg, parent=None):
        super(ZipToTiff, self).__init__(parent)
        self.__filelist = arg
        self.stopped = False

    def run(self):
        self.memoAdd.emit("実行します...")

        for z in self.__filelist:
            folder = os.path.dirname(z)

            with zipfile.ZipFile(z, 'r') as zf:
                decomp = zf.namelist()
                for dfile in decomp:

                    # キャンセルされた
                    if self.stopped:                        
                        self.memoAdd.emit("中止しました")
                        return

                    with zf.open(dfile, 'r') as file:
                        gmldem = JpGisGML()
                        text = file.read().decode('utf_8')
                        gmldem.ReadText(text)
                        savefilename = gmldem.ToGeoTiff(os.path.dirname(z))
                        self.memoAdd.emit(gmldem.GetMeshCode() + "...OK!")
                        self.decompfileAdd.emit(savefilename)

        self.finish.emit()

class JpGisGML :
    def __init__(self) :
        self.__ns = {
            'ns' : 'http://fgd.gsi.go.jp/spec/2008/FGD_GMLSchema',
            'gml' : 'http://www.opengis.net/gml/3.2',
            'xsi' : 'http://www.w3.org/2001/XMLSchema-instance',
            'xlink' : 'http://www.w3.org/1999/xlink'
        }
        self.__nodata = -9999

    def GetMeshCode(self):
        return self.__meshcode

    def ReadText(self, text) :
        root = et.fromstring(text)
        dem = root.find('ns:DEM', self.__ns)
        coverage = dem.find('ns:coverage', self.__ns)
        envelope = coverage.find('gml:boundedBy//gml:Envelope', self.__ns)
        grid = coverage.find('gml:gridDomain//gml:Grid//gml:limits//gml:GridEnvelope', self.__ns)
        gridfunc = coverage.find('gml:coverageFunction//gml:GridFunction', self.__ns)

        #メッシュコード
        mesh = dem.find('ns:mesh', self.__ns)
        self.__meshcode = mesh.text

        #左下、右上の座標取得
        str = envelope.find('gml:lowerCorner', self.__ns).text.split(' ')
        self.__yllcorner, self.__xllcorner = float(str[0]),float(str[1])
        str = envelope.find('gml:upperCorner', self.__ns).text.split(' ')
        self.__yucorner, self.__xucorner = float(str[0]),float(str[1])

        #行、列数取得
        str = grid.find('gml:low', self.__ns).text.split(' ')
        lowx,lowy = int(str[0]),int(str[1])
        str = grid.find('gml:high', self.__ns).text.split(' ')
        highx,highy = int(str[0]),int(str[1])
        self.__ncol = highx - lowx + 1
        self.__nrow = highy - lowy + 1

        #セルサイズ
        self.__cellsize_x = (self.__xucorner - self.__xllcorner) / self.__ncol
        self.__cellsize_y = (self.__yucorner - self.__yllcorner) / self.__nrow

        #標高値取得
        self.__dem = np.zeros([self.__nrow, self.__ncol])
        self.__dem.fill(self.__nodata)
        str = gridfunc.find('gml:startPoint', self.__ns).text.split(' ')
        x,y = int(str[0]), int(str[1])
        datapoints = coverage.find('gml:rangeSet//gml:DataBlock//gml:tupleList', self.__ns).text.splitlines()
        for datapoint in datapoints:
            str = datapoint.split(',')
            if len(str) == 1: continue
            desc,value = str[0],np.float64(str[1])
            if (desc == '地表面') or (desc == '表層面') or (desc == 'その他'):
                self.__dem[y][x] = value
            x += 1
            if x > highx:
                x = 0
                y += 1
            if y > highy:
                break

    def ToGeoTiff(self, savefoldername) :
        savetiffilename = savefoldername + "/"+ self.__meshcode + ".tif"

        driver = gdal.GetDriverByName("GTiff")
        dst_ds = driver.Create(savetiffilename, self.__ncol, self.__nrow, 1, gdal.GDT_Float32)

        dst_ds.SetProjection('GEOGCS["JGD2000",DATUM["Japanese_Geodetic_Datum_2000",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6612"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4612"]]')
        geotransform = [self.__xllcorner, self.__cellsize_x, 0, self.__yucorner, 0, -self.__cellsize_y]
        dst_ds.SetGeoTransform(geotransform)

        rband = dst_ds.GetRasterBand(1)
        rband.WriteArray(self.__dem)
        rband.SetNoDataValue(self.__nodata)

        # ファイルに書き込み
        dst_ds.FlushCache()

        return savetiffilename
